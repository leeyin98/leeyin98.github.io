<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>package小错误</title>
      <link href="/posts/34c1.html"/>
      <url>/posts/34c1.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228195144.png" alt=""></p><h3 id="2-问题原因"><a href="#2-问题原因" class="headerlink" title="2. 问题原因"></a>2. 问题原因</h3><p>已使用package包，但却未表明源程序位于什么路径下</p><h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><p>在第一行添加代码：<code>package test00;</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo解析出错问题</title>
      <link href="/posts/c6bf.html"/>
      <url>/posts/c6bf.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>在写Java基础知识笔记，使用<code>hexo g</code>生成文章是，出现如下报错：</p><pre><code>FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlNunjucks Error:  [Line 143, Column 15] expected variable end</code></pre><h3 id="2-问题原因"><a href="#2-问题原因" class="headerlink" title="2. 问题原因"></a>2. 问题原因</h3><p>在Hexo故障排除文档<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">文档链接</a>中发现问题原因：<br>当文章中同时才出现两个花括号<code>}}</code>时，且两个花括号未被代码块包含时，解析会出现问题(使用单`包含无作用)</p><h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3. 解决方法"></a>3. 解决方法</h3><p>使用特定代码将含有两个花括号的内容包含，如：</p><pre><code>{% raw %}Hello {{ sensitive }}       //同时出现两个花括号的内容{% endraw %}</code></pre><h5 id="问题解决参考来源"><a href="#问题解决参考来源" class="headerlink" title="问题解决参考来源"></a>问题解决参考来源</h5><p><a href="https://hexo.io/docs/troubleshooting" target="_blank" rel="noopener">Hexo官方故障排除文档</a><br><a href="https://www.jianshu.com/p/738ebe02029b" target="_blank" rel="noopener">Hexo的一个小BUG</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 问题记录及解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题记录及解决 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识笔记10</title>
      <link href="/posts/19f.html"/>
      <url>/posts/19f.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java知识笔记9</title>
      <link href="/posts/1932.html"/>
      <url>/posts/1932.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java知识笔记8</title>
      <link href="/posts/d9f3.html"/>
      <url>/posts/d9f3.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java知识笔记7</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础6. 异常处理与程序调试</title>
      <link href="/posts/1d72.html"/>
      <url>/posts/1d72.html</url>
      
        <content type="html"><![CDATA[<h1 id="第5讲-异常处理与程序调试"><a href="#第5讲-异常处理与程序调试" class="headerlink" title="第5讲 异常处理与程序调试"></a>第5讲 异常处理与程序调试</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第6讲主要讲述：异常处理；自定义异常；断言及程序的测试；程序的调试</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1. 异常处理"></a>1. 异常处理</h3><h4 id="1-1-异常定义"><a href="#1-1-异常定义" class="headerlink" title="1.1 异常定义"></a>1.1 异常定义</h4><p>异常，对应着Java运行错误的处理机制</p><h5 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h5><pre><code>try{    语句组;}catch(Exception ex){    异常处理语句组;}</code></pre><h5 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h5><p>1.抛出(throw)异常<br>2.运行时系统在调用栈中查找<br>3.捕获(catch)异常的代码<br>相关语句：</p><pre><code>抛出异常：`throw 异常对象;`捕获异常：try{    语句组}catch(异常类名 异常形式参数名){    异常处理语句组;}catch(异常类名 异常形式参数名){    异常处理语句组;}finally{    异常处理语句组;}其中，catch语句可以是0或多个，可以没有fanally语句</code></pre><h4 id="1-2-异常分类"><a href="#1-2-异常分类" class="headerlink" title="1.2 异常分类"></a>1.2 异常分类</h4><p><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228194514.png" alt=""><br>Error：JVM的错误<br>Exception：异常，其构造方法为：</p><ul><li><code>public Exception();</code></li><li><code>public Exception(String message);</code></li><li><code>Exception(String message,Throwable cause);</code></li></ul><h4 id="1-3-多异常处理"><a href="#1-3-多异常处理" class="headerlink" title="1.3 多异常处理"></a>1.3 多异常处理</h4><p>子类异常要写在父类异常前面<br>finally语句：无论是否有异常都要执行，即使其中有break,return等语句</p><h4 id="1-4-受检的异常"><a href="#1-4-受检的异常" class="headerlink" title="1.4 受检的异常"></a>1.4 受检的异常</h4><p>Exception分为两种：</p><ul><li>RuntimeException及其子类，可以不明确处理</li><li>否则，称为受检的异常(checked Exception)<br>受检的异常，要求明确进行语法处理：</li><li>要么捕获(catch)</li><li>要么抛出(throws)：在方法的签名后面用throws xxxx来声明</li></ul><h3 id="2-自定义异常"><a href="#2-自定义异常" class="headerlink" title="2. 自定义异常"></a>2. 自定义异常</h3><h4 id="2-1-创建用户自定义异常"><a href="#2-1-创建用户自定义异常" class="headerlink" title="2.1 创建用户自定义异常"></a>2.1 创建用户自定义异常</h4><p>继承自Exception类或某个子Exception类<br>定义属性和方法，或重载父类的方法</p><h4 id="2-2-重抛异常及异常链接"><a href="#2-2-重抛异常及异常链接" class="headerlink" title="2.2 重抛异常及异常链接"></a>2.2 重抛异常及异常链接</h4><p>对于异常，不仅要进行捕获处理，优势也要将此异常进一步传递给调用者，以便让调用者也能感受到这种异常，这时可以在catch语句块或finally语句块中采取以下三种方式：</p><ul><li>将当前捕获的异常再次抛出<ul><li><code>throw e;</code></li></ul></li><li>重新生成一个异常并抛出，如<ul><li><code>throw new Exception("some message");</code></li></ul></li><li>重新生成并抛出一个新异常，该异常中包含了当前异常的信息，如<ul><li><code>throw new Exception("some message",e);</code>可用<code>e.getCause()</code>得到内部异常</li></ul></li></ul><h3 id="3-断言及程序的测试"><a href="#3-断言及程序的测试" class="headerlink" title="3. 断言及程序的测试"></a>3. 断言及程序的测试</h3><h4 id="3-1-断言-assertion"><a href="#3-1-断言-assertion" class="headerlink" title="3.1 断言(assertion)"></a>3.1 断言(assertion)</h4><p>assert的写法：</p><ul><li><code>assert 表达式;</code></li><li><code>assert 表达式：信息;</code><br>例：<pre><code>class Assertion{  public static void main(String[] args){      assert hypotenuse(3,4)==5 : "算法不正确";   //assert写法  }  static double hypotenuse(double x,double y){      return Math.sqrt(x*x+y*y+1);  }}</code></pre><code>调试程序时，若表达式部位true，则程序会产生异常并输出相关的错误信息</code></li></ul><h4 id="3-2-程序的测试及Junit"><a href="#3-2-程序的测试及Junit" class="headerlink" title="3.2 程序的测试及Junit"></a>3.2 程序的测试及Junit</h4><p>Eclipse中</p><ul><li>项目上右键-New-Junit Test Case</li><li>项目上右键-Run as-Junit Test</li></ul><h4 id="3-3-测试函数"><a href="#3-3-测试函数" class="headerlink" title="3.3 测试函数"></a>3.3 测试函数</h4><p><code>@Test</code>用来标注测试函数<br>测试中常用的语句：</p><ul><li><code>fail(信息);</code>             //表示程序出错</li><li><code>assertEquals(参数1,参数2);</code>      //表示程序要保证两个参数相等</li><li><code>assertNull(参数);</code>     //表示参数要为null</li></ul><h3 id="4-程序的调试"><a href="#4-程序的调试" class="headerlink" title="4. 程序的调试"></a>4. 程序的调试</h3><h4 id="4-1-程序中的错误"><a href="#4-1-程序中的错误" class="headerlink" title="4.1 程序中的错误"></a>4.1 程序中的错误</h4><p>程序中的错误，通常分为三大类：</p><ul><li>语法错误(Syntax error)<ul><li>编辑、编译器发现</li></ul></li><li>运行错误(Runtime error)<ul><li>异常处理机制</li></ul></li><li>逻辑错误(Logic error)<ul><li>调试(debug)、单元测试(unit test)</li></ul></li></ul><h4 id="4-2-程序的调试-debug"><a href="#4-2-程序的调试-debug" class="headerlink" title="4.2 程序的调试(debug)"></a>4.2 程序的调试(debug)</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>1.在IDE中，项目上右键，debug as…<br>2.进入到调试试图(debug perspective)</p><h5 id="调试的手段"><a href="#调试的手段" class="headerlink" title="调试的手段"></a>调试的手段</h5><ul><li>断点(breakpoint)：<ul><li>切换断点：鼠标右击编译器左边条；Eclipse快捷键：Ctrl+Shift+B</li></ul></li><li>跟踪(trace)：<ul><li>Eclipse快捷键</li><li>逐语句执行：F5</li><li>逐过程执行：F6</li><li>跳出函数：F7</li><li>运行到光标处：Ctrl+R</li></ul></li><li>监视(watch)<ul><li>即时监视：鼠标指向变量</li><li>快速监视：点右键，Inspector</li><li>添加监视：点右键，Watch</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础5. 深入理解Java语言</title>
      <link href="/posts/1c32.html"/>
      <url>/posts/1c32.html</url>
      
        <content type="html"><![CDATA[<h1 id="第5讲-深入理解Java语言"><a href="#第5讲-深入理解Java语言" class="headerlink" title="第5讲 深入理解Java语言"></a>第5讲 深入理解Java语言</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第5讲主要讲述：变量及其传递；多态及虚方法调用；对象的构造与初始化；对象清除与垃圾回收；内部类与匿名类；其他几个高级语法；没有指针的Java语言</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-变量及其传递"><a href="#1-变量及其传递" class="headerlink" title="1. 变量及其传递"></a>1. 变量及其传递</h3><h4 id="1-1-变量类型及含义"><a href="#1-1-变量类型及含义" class="headerlink" title="1.1 变量类型及含义"></a>1.1 变量类型及含义</h4><ul><li>基本类型变量：其值直接存在于变量中</li><li>引用类型变量：变量占据预定的内存空间，其所引用的对象实体(由new创建)也要占据一定的空间</li><li>字段变量：存在于类中</li><li>局部变量：方法中定义的变量和方法的参变量</li></ul><h4 id="1-2-字段变量与局部变量的比较："><a href="#1-2-字段变量与局部变量的比较：" class="headerlink" title="1.2 字段变量与局部变量的比较："></a>1.2 字段变量与局部变量的比较：</h4><blockquote><ol><li>字段变量为对象的一部分、存在于堆中，局部变量存在于栈中</li><li>字段变量随对象创建而产生，局部变量在调用方法时产生，方法结束后释放</li><li>字段变量可以自动赋初值，局部变量则须显式赋值,如<pre><code>class Test(){int a;      //字段变量void m(){    intb;       //局部变量    System.out.println(b);  //编译不能通过，需要初始化b}}</code></pre></li><li>字段变量属于类，可以用public,private,static,final修饰</li><li>局部变量不能被访问控制符及static修饰，但都能被final修饰</li><li>调用对象方法时要传递参数</li><li>Java是值传递，即将表达式的值赋值给形式参数</li><li>对于引用型变量，传递的值是引用值，而不是赋值对象实体(可改变对象属性)</li></ol></blockquote><h3 id="2-多态及虚方法调用"><a href="#2-多态及虚方法调用" class="headerlink" title="2. 多态及虚方法调用"></a>2. 多态及虚方法调用</h3><p>多态的两种情形：</p><ul><li>编译时多态：重载（overload）多个同名的不同方法<br> 例：<code>p.sayHello();   p.sayHello("Wang");</code></li><li>运行时多态：覆盖（override）子类对父类方法进行覆盖<ul><li>在调用方法时，程序会自动正确地调用子类对象的方法</li></ul></li></ul><p>上溯造型：可以把派生类型当做基本类型处理<br>例：<code>Person p = new Student();</code></p><h3 id="3-对象的构造与初始化"><a href="#3-对象的构造与初始化" class="headerlink" title="3. 对象的构造与初始化"></a>3. 对象的构造与初始化</h3><h4 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h4><p>对象都有构造方法，抽象类(abstract)也有构造方法，若没有，编译器会加一个default构造方法</p><h4 id="3-2-调用本类或父类的构造方法"><a href="#3-2-调用本类或父类的构造方法" class="headerlink" title="3.2 调用本类或父类的构造方法"></a>3.2 调用本类或父类的构造方法</h4><ul><li>this调用本类的其他构造方法</li><li>super调用直接父类的构造方法</li><li>this或super要放在第一条语句，且只能有一条</li><li>若没有this和super，编译器会自动加上super，调用直接父类不带参数的构造方法</li></ul><h4 id="3-3-创建对象时初始化"><a href="#3-3-创建对象时初始化" class="headerlink" title="3.3 创建对象时初始化"></a>3.3 创建对象时初始化</h4><p>例： p=new Person(){{ age=18;name="leeyin98";}}; <br>这样可以针对没有相应构造函数，但又要赋值，注意双括号<br>实例初始化:</p><ul><li>在类中直接写语句，{ 语句… }<br>静态初始化:</li><li>static{ 语句… }</li><li>静态初始化在一地刺使用这个类时要执行</li></ul><h4 id="3-4-构造方法的执行过程"><a href="#3-4-构造方法的执行过程" class="headerlink" title="3.4 构造方法的执行过程"></a>3.4 构造方法的执行过程</h4><ol><li>调用本类或父类的构造方法，直至最高一层（Object）</li><li>按照声明顺序执行字段的初始化赋值</li><li>执行构造函数中的语句<br><code>总结</code>：先父类构造，再本类成员赋值，最后执行构造方法中的语句</li></ol><h3 id="4-对象清除与垃圾回收"><a href="#4-对象清除与垃圾回收" class="headerlink" title="4. 对象清除与垃圾回收"></a>4. 对象清除与垃圾回收</h3><ul><li>try-with-resources语句<pre><code>对于实现了java.lang.AutoCloseable的对象，try(Scanner scanner = new Scanner(...)){  代码块}会自动调用close()方法，相当于：finally{  Scanner.close();}</code></pre>注：<code>当try第一个花括号结束后，会自动调用对象的close()方法，无论花括号内的程序是否正常</code></li></ul><h3 id="5-内部类与匿名类"><a href="#5-内部类与匿名类" class="headerlink" title="5. 内部类与匿名类"></a>5. 内部类与匿名类</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>内部类：在其他类中再定义的类<br>匿名类：是一种特殊的内部类，没有类型</p><h4 id="5-2-内部类的定义及使用"><a href="#5-2-内部类的定义及使用" class="headerlink" title="5.2 内部类的定义及使用"></a>5.2 内部类的定义及使用</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><ul><li>将类的定义<code>class xxxx{…}</code>置入一个类的内部即可</li><li>编译器生成<code>xxxx$xxxx</code>这样的class文件</li><li>内部类不能与外部类同名<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5></li><li>在封装它的类的内部使用内部类时，与普通类的使用方式相同</li><li>在其他地方使用时，类名前要冠以外部类的名字</li><li>在用new创建内部类时，也要在new前面冠以对象变量<br>  例：<code>外部对象名.new 内部类名(参数)</code></li><li>内部类中可以直接访问外部类的字段及方法（即使private也可以）</li><li>若内部类中又与外部类同名的字段或方法，则可用 <code>外部类名.this.字段及方法</code></li></ul><h4 id="5-3-内部类的修饰符"><a href="#5-3-内部类的修饰符" class="headerlink" title="5.3 内部类的修饰符"></a>5.3 内部类的修饰符</h4><p>内部类与类中的字段、方法一样是外部类的成员，它的前面也可以有访问控制符合其他修饰符（public,protected,private及默认，final,abstract），而外部类只能用public或默认</p><h4 id="5-4-static修饰符"><a href="#5-4-static修饰符" class="headerlink" title="5.4 static修饰符"></a>5.4 static修饰符</h4><ul><li>用static修饰内部类时，则表明内部类实际是一种外部类(因为它与外部类的实例无关)</li><li>实例化static类时，在new前面不需要用对象实例变量;</li><li>static类中不能访问其外部类的非stati字段及方法，即只能访问static成员</li><li>static方法中不能访问非static的域及方法，也不能不带前缀地new一个非static的内部类</li></ul><h4 id="5-5-局部类"><a href="#5-5-局部类" class="headerlink" title="5.5 局部类"></a>5.5 局部类</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>在一个方法中也可以定义类，这种类称为”方法中的内部类”，即局部类</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul><li>同局部变量一样，不能被public,private,protected,static修饰，但能被final或abstract修饰</li><li>可以访问其外部类的成员</li><li>不能访问该方法的局部变量，除非是final局部变量</li></ul><h4 id="5-6-匿名类"><a href="#5-6-匿名类" class="headerlink" title="5.6 匿名类"></a>5.6 匿名类</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>匿名类是一种没有类名的特殊的内部类，在定义类的同时生成该对象的一个实例</p><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><ul><li>不取名字，直接用其父类或接口的名字，也就是说该类时父类的子类或实现了一个接口</li><li>类的定义的同时就创建实例，即类的定义前面有一个new，不使用关键词class也不实用extends及implements（例：<code>new 类名或接口名 () {….}</code>）</li><li>在构造对象时使用父类构造方法，不能定义构造方法</li></ul><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul><li>界面的时间处理，即注册一个事件监听器</li><li>作为方法的参数，即给一个比较大小的接口并排序</li></ul><h4 id="5-7-Lambda表达式"><a href="#5-7-Lambda表达式" class="headerlink" title="5.7 Lambda表达式"></a>5.7 Lambda表达式</h4><ul><li>大体相当于其他语言的“函数指针”，在Java中实际上是“匿名类的一个实例”</li><li>Lambda表达式是接口或者说是接口函数的简写，可用于线程、积分和按钮事件处理等问题中<h5 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h5><code>(参数) -&gt; 结果</code>  例：<code>(String s) -&gt; s.length()</code>  , <code>x -&gt; x*x</code><br>  这里的参数是()或1个参数或(多个参数)，结果是指表达式或语句或{语句}<h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5>能写成Lambda的接口要求包含且最多只能有一个抽象函数<br>例：<pre><code>Runnable dolt = new Runnable(){  public void run(){      System.out.println("leeyin98");  }};new Thread(dolt).start();使用Lambda可简写成：Runnable doIt = () -&gt;System.out.println("leeyin98");new thread(doIt).start();再进一步简写：new Thread(()-&gt;System.out.println("leeyin98")).start();</code></pre></li></ul><h3 id="6-其他几个高级语法"><a href="#6-其他几个高级语法" class="headerlink" title="6. 其他几个高级语法"></a>6. 其他几个高级语法</h3><h4 id="6-1-基本类型的包装类"><a href="#6-1-基本类型的包装类" class="headerlink" title="6.1 基本类型的包装类"></a>6.1 基本类型的包装类</h4><p>将基本类型包装成Object(引用类型)，如int→Interger<br>共8类：Boolean,Byte,Short,Character,Integer,Long,Float,Double</p><h4 id="6-2-装箱与拆箱"><a href="#6-2-装箱与拆箱" class="headerlink" title="6.2 装箱与拆箱"></a>6.2 装箱与拆箱</h4><ul><li>装箱(Boxing)，将基本类型数值直接赋值给引用类型。如Interger I=10;</li><li>拆箱(Unboxing)，将一个引用类型复制到基本类型数值中去。如int i=I;</li></ul><h4 id="6-3-枚举"><a href="#6-3-枚举" class="headerlink" title="6.3 枚举"></a>6.3 枚举</h4><p>枚举是一种特殊的class类型<br>在简单情况下，用法与其他语言相似，如<code>enum Light {Red,Yellow,Green};</code><br>自定义枚举，可在enum定义体重，添加字段、方法和构造方法，例：</p><pre><code>enum Direction{    EAST("东",1),SOUTH("南",2),WEST("西",3),NORTH("北",4);    Private Direction(String desc,int num){        this.desc=desc;        this.num=num;    }    private String desc;    private int num;    public String getDesc(){return desc;}    public int getNum(){return num;}}</code></pre><h4 id="6-4-注解"><a href="#6-4-注解" class="headerlink" title="6.4 注解"></a>6.4 注解</h4><p>在各种语法要素上加上附加信息，以供编译器或其他程序使用<br>常用的注解，如：</p><ul><li>@Override——表示覆盖父类的方法</li><li>@Deprecated——表示过时的方法</li><li>@SuppressWarnings——表示让编译器不产生警告</li></ul><h3 id="7-没有指针的Java语言"><a href="#7-没有指针的Java语言" class="headerlink" title="7. 没有指针的Java语言"></a>7. 没有指针的Java语言</h3><h4 id="7-1-引用与指针"><a href="#7-1-引用与指针" class="headerlink" title="7.1 引用与指针"></a>7.1 引用与指针</h4><p>在Java中，引用实质就是指针，但它是受控的且安全的，比如</p><ul><li>会检查空指引</li><li>没有指针运算</li><li>不能访问没有引用到的内存</li><li>自动回收垃圾</li></ul><h4 id="7-2-C语言指针在Java中的体现"><a href="#7-2-C语言指针在Java中的体现" class="headerlink" title="7.2 C语言指针在Java中的体现"></a>7.2 C语言指针在Java中的体现</h4><table><thead><tr><th>C</th><th align="center">JAVA</th></tr></thead><tbody><tr><td>传地址</td><td align="center">对象</td></tr><tr><td>指针运算</td><td align="center">数组</td></tr><tr><td>函数指针</td><td align="center">接口、Lambda表达式</td></tr><tr><td>指向节点的指针</td><td align="center">对象的引用</td></tr><tr><td></td><td align="center">JNI:与其他语言代码进行交互</td></tr></tbody></table><h4 id="7-3-相等判断（-）"><a href="#7-3-相等判断（-）" class="headerlink" title="7.3 相等判断（==）"></a>7.3 相等判断（==）</h4><ul><li>基本类型：判断值是否相等<ul><li>数值类型，转换后比较</li><li>浮点数，最好不直接用==</li><li>Double.NAN==Double.NAN结果为false</li><li>boolean型无法与int比较<br>如：<br>```</li></ul></li></ul><p>1.<br>Integer i = new Integer(10);<br>Integer j = new Integer(10);<br>System.out.printlb(i==n);   //false,因为对象是两个<br>2.<br>Integer m = 10;<br>Integer n = 10;<br>System.out.println(m==n);   //true,因为对象有缓存，缓存区间：-128~127<br>3.<br>Integer p = 200;<br>Integer q = 200;<br>System.out.println(p==q);   //false,因为对象是两个</p><p>```</p><ul><li>引用类型：判断引用是否一样<br>若要判断内容是否一样，则要重写equals方法，那最好重写hashCode()方法</li></ul><h4 id="7-4-String对象的特殊性"><a href="#7-4-String对象的特殊性" class="headerlink" title="7.4 String对象的特殊性"></a>7.4 String对象的特殊性</h4><p>String对象判断是否相等，一定不要用==，要用equals。（变量）<br>但字符串常量的相等还是用==</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础.4  类、包和接口</title>
      <link href="/posts/dcf3.html"/>
      <url>/posts/dcf3.html</url>
      
        <content type="html"><![CDATA[<h1 id="第4讲-类、包和接口"><a href="#第4讲-类、包和接口" class="headerlink" title="第4讲 类、包和接口"></a>第4讲 类、包和接口</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第4讲主要讲述：类、字段、方法；类的继承；访问控制修饰符；</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-类、字段、方法"><a href="#1-类、字段、方法" class="headerlink" title="1. 类、字段、方法"></a>1. 类、字段、方法</h3><h4 id="1-1-类"><a href="#1-1-类" class="headerlink" title="1.1 类"></a>1.1 类</h4><ul><li>组成java程序的基本要素</li><li>字段（field）是类的属性，用变量表示</li><li>方法（method）是类的功能和操作，用函数表示</li><li>封装了一类对象的状态和方法，即它将变量和函数封装到一个类中，如<pre><code>class Person{  String name;    //变量  int age;     //变量  void sayHello(){        //函数      System.out.println("Hello!My name is"+name);  }}</code></pre><h4 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h4>用来初始化（new）该类的一个新的对象，如：<code>Person p = new Person()</code><br>构造方法和类名同名，且不写返回数据类型</li></ul><h4 id="1-3-使用对象"><a href="#1-3-使用对象" class="headerlink" title="1.3 使用对象"></a>1.3 使用对象</h4><p>访问对象的字段或方法，需要用算符“.”  如：</p><pre><code>Person p = new Person();System.out.println(p.name)；p.sayHello()；</code></pre><h4 id="1-4-方法重载"><a href="#1-4-方法重载" class="headerlink" title="1.4 方法重载"></a>1.4 方法重载</h4><ul><li>多个方法有相同的名字，编译时也能识别出来</li><li>这些同名方法的签名不同，或参数个数或参数类型不同</li><li>通过方法重载可以实现多态</li></ul><h4 id="1-5-this的使用"><a href="#1-5-this的使用" class="headerlink" title="1.5 this的使用"></a>1.5 this的使用</h4><ul><li>在方法及构造方法中，使用this来访问字段及方法</li><li>解决局部变量与域同名的问题，如：<br>  ```<br>  Person(int age,String name){<pre><code>  this.age = age;    //this.age表示域变量，age表示参数变量  this.name = name;</code></pre>  }</li><li>构造方法中，用this调用另一个构造方法，但调用语句必须放第一句</li></ul><h3 id="2-类的继承"><a href="#2-类的继承" class="headerlink" title="2. 类的继承"></a>2. 类的继承</h3><h4 id="2-1-继承"><a href="#2-1-继承" class="headerlink" title="2.1 继承"></a>2.1 继承</h4><ul><li>继承是面向对象的程序设计中最为重要的特征之一</li><li>Java中的继承是通过extends关键词来实现的</li><li>字类、父类或超类（父类包括直接或间接被继承的类）</li><li>Java支持单继承：一个类只能有一个直接父类</li><li>子类继承父类的状态和行为(字段和方法，构造方法不可继承）<br>  -可以修改父类的状态或重载父类的行为(字段和方法）<br>  -可以添加新的状态和行为(字段和方法）</li></ul><h4 id="2-2-super的使用"><a href="#2-2-super的使用" class="headerlink" title="2.2 super的使用"></a>2.2 super的使用</h4><ul><li>使用super访问父类的域和方法，this也可以，但用super更加明确</li><li>有时需要使用super以区别同名的域与方法</li><li>构造方法不可继承，但子类在构造方法中可以用super来调用父类的构造方法<ul><li>使用时，super()必须放在第一句</li></ul></li></ul><h4 id="2-3-父类对象与子类对象的转换"><a href="#2-3-父类对象与子类对象的转换" class="headerlink" title="2.3 父类对象与子类对象的转换"></a>2.3 父类对象与子类对象的转换</h4><ul><li>子类对象可以被视为其父类的一个对象</li><li>父类对象不能被当做其子类的一个对象</li><li>若一个方法的形式参数定义的是父类对象，那么调用该方法时，可以使用子类对象作为实际参数</li><li>若父类对象引用指向的实际是一个子类对象，那么这个父类对象的引用可以用强制类型转换成子类对象的引用</li></ul><h4 id="2-4-package包"><a href="#2-4-package包" class="headerlink" title="2.4 package包"></a>2.4 package包</h4><ul><li><code>package pkg1[.pkg2[.pkg3…..]]</code></li><li>包与子包的定义，实际是为了解决名字空间、名字冲突</li><li>与类的继承无关，一个子类与其父类可位于不同的包中</li><li>同一个包中的各个类，默认情况下可互相访问</li><li>使用java中已提供的类，需要用import语句来导入所需要的类。</li><li>语句格式：<code>import package1[.package2…].(classname|*)</code>;如：<ul><li><code>import java.awt.event.*;</code></li></ul></li></ul><h3 id="3-访问控制修饰符"><a href="#3-访问控制修饰符" class="headerlink" title="3. 访问控制修饰符"></a>3. 访问控制修饰符</h3><h4 id="3-1-可见性，即能在哪些地方被使用"><a href="#3-1-可见性，即能在哪些地方被使用" class="headerlink" title="3.1 可见性，即能在哪些地方被使用"></a>3.1 可见性，即能在哪些地方被使用</h4><table><thead><tr><th></th><th align="center">同一个类中</th><th align="center">同一个包中</th><th align="center">不同包中的子类</th><th align="center">不包中的非子类</th></tr></thead><tbody><tr><td>private</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>默认</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td>protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td>public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><h4 id="3-2-private修饰"><a href="#3-2-private修饰" class="headerlink" title="3.2 private修饰"></a>3.2 private修饰</h4><p>将字段用private修饰，用setXXXX与getXXXX方法对类的属性进行存取<br>优点：</p><ul><li>属性用prvate更好地封装和隐藏，外部类不能随意存取和修改</li><li>提供方法来存取对象的属性，在方法中可以对给定的参数的合法性进行校验</li><li>方法可以用来给出计算后的值</li><li>方法可以完成其他必要的工作（如清理资源、设定状态等）</li><li>只提供getXXXX方法，而不提供setXXXX方法，可以保证属性是只读的<br>例：<pre><code>class Person2{  private int age;  public void setAge(int age){      if(age&gt;0 &amp;&amp; age&lt;200) this.age = age;  }  public int getAge(){      return age;  }}</code></pre></li></ul><h4 id="3-3-非访问控制符"><a href="#3-3-非访问控制符" class="headerlink" title="3.3 非访问控制符"></a>3.3 非访问控制符</h4><table><thead><tr><th></th><th align="center">基本含义</th><th align="center">修饰类</th><th align="center">修饰成员</th><th align="center">修饰局部变量</th></tr></thead><tbody><tr><td>static</td><td align="center">静态的、非实例的、类的</td><td align="center">可修饰内部类</td><td align="center">√</td><td align="center"></td></tr><tr><td>final</td><td align="center">最终的、不可改变的</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td>abstract</td><td align="center">抽象的、不可实例化的</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr></tbody></table><h4 id="3-4-接口-interface"><a href="#3-4-接口-interface" class="headerlink" title="3.4 接口(interface)"></a>3.4 接口(interface)</h4><ul><li>定义接口interface，如<code>interface Collection{....}</code></li><li>实现接口implements，如<code>class FIFOQueue implements Collection{...}</code></li><li>作用：<ul><li>通过接口可以实现不相关类的相同行为，而不需要考虑这些类之间的层次关系，从而在一定意义上实现了多重继承</li><li>通过接口可以指明多个类需要实现的方法</li><li>通过接口可以了解对象的交互界面，而不需要了解对象所对应的类</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础.3 数据运算、流控制和数组</title>
      <link href="/posts/1eb2.html"/>
      <url>/posts/1eb2.html</url>
      
        <content type="html"><![CDATA[<h1 id="第3讲-数据运算、流程控制和数组"><a href="#第3讲-数据运算、流程控制和数组" class="headerlink" title="第3讲 数据运算、流程控制和数组"></a>第3讲 数据运算、流程控制和数组</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第3讲主要讲述：数据类型、变量与常量；运算符与表达式；流程控制语句；数组</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-数据类型、变量与常量"><a href="#1-数据类型、变量与常量" class="headerlink" title="1. 数据类型、变量与常量"></a>1. 数据类型、变量与常量</h3><h4 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h4><ul><li>基本类型：变量在栈</li><li>引用类型：变量引用到堆<ul><li>double d = 3;</li><li>Person p = new Preson();<br>赋值时：</li><li>double d2=d;     复制的是值</li><li>Person p2=p;     复制的是引用<br><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228143215.png" alt=""></li></ul></li></ul><h4 id="1-2-数据类型"><a href="#1-2-数据类型" class="headerlink" title="1.2 数据类型"></a>1.2 数据类型</h4><p><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228143338.png" alt=""></p><ul><li>常用的基本数据类型<table><thead><tr><th>数据类型</th><th align="center">说明</th><th align="center">字节</th><th align="center">应用</th><th align="center">示例</th></tr></thead><tbody><tr><td>int</td><td align="center">整型</td><td align="center">4</td><td align="center">用于存储整数，如年龄、个数</td><td align="center">int age=21;</td></tr><tr><td>double</td><td align="center">双精度浮点型</td><td align="center">8</td><td align="center">用于存储小数，如商品价格</td><td align="center">double price=15.5;</td></tr><tr><td>float</td><td align="center">单精度浮点型</td><td align="center">4</td><td align="center">用于存储小数，如身高</td><td align="center">float height=175.2f;</td></tr><tr><td>char</td><td align="center">字符型</td><td align="center">2</td><td align="center">用于存储单个字符，如性格’男’</td><td align="center">char sex=’男’;</td></tr><tr><td>boolean</td><td align="center">布尔型</td><td align="center">1</td><td align="center">表示真或假，取值只能为true或false</td><td align="center">boolean flag=true;</td></tr></tbody></table></li></ul><p>注：</p><ul><li>为float变量赋值时在数值后添加字母f</li><li>为char变量赋值时使用单引号引起来</li><li>String是一种常见的引用数据类型，用来表示字符串，赋值时用双引号引起来</li><li>Java中没有“无符号数”</li></ul><h3 id="2-运算符表达式"><a href="#2-运算符表达式" class="headerlink" title="2. 运算符表达式"></a>2. 运算符表达式</h3><h4 id="2-1-算术运算符"><a href="#2-1-算术运算符" class="headerlink" title="2.1 算术运算符"></a>2.1 算术运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228145919.png" alt=""></p><h4 id="2-2-赋值运算符"><a href="#2-2-赋值运算符" class="headerlink" title="2.2 赋值运算符"></a>2.2 赋值运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228145929.png" alt=""></p><h4 id="2-3-比较运算符"><a href="#2-3-比较运算符" class="headerlink" title="2.3 比较运算符"></a>2.3 比较运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228145941.png" alt=""></p><h4 id="2-4-逻辑运算符"><a href="#2-4-逻辑运算符" class="headerlink" title="2.4 逻辑运算符"></a>2.4 逻辑运算符</h4><p><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228145949.png" alt=""></p><h4 id="2-5-位运算符"><a href="#2-5-位运算符" class="headerlink" title="2.5 位运算符"></a>2.5 位运算符</h4><ol><li>~：取反</li><li>&amp;：按位与</li><li>|：按位或</li><li>^：按位异或</li></ol><h4 id="2-6-移位运算符"><a href="#2-6-移位运算符" class="headerlink" title="2.6 移位运算符"></a>2.6 移位运算符</h4><ul><li>左移：”a&lt;&lt;b;”  将二进制形式的a逐位左移b位，最低位空出的b位补0</li><li>无符号右移：”a&gt;&gt;&gt;b;”  将二进制形式的a逐位右移b位，最低位空出的b位补0</li><li>带符号右移：”a&gt;&gt;b;”  将二进制形式的a逐位右移b位，最高位空出的b位补原来的符号位</li></ul><h4 id="2-7-条件运算符"><a href="#2-7-条件运算符" class="headerlink" title="2.7 条件运算符"></a>2.7 条件运算符</h4><p>语法形式：布尔表达式 ？ 表达式1 ：表达式2<br>运算过程：如果布尔表达式的值为true，则返回表达式1的值，否则返回表达式2的值。<br>例如：</p><pre><code>String str = (8&gt;5) ? "8大于5" : "8不大于5" ;System.out.println(str);</code></pre><p>因为表达式8&gt;5为true，所以返回“8大于5”</p><h4 id="2-8-Java中运算符的优先级（从上到下，由高到低）"><a href="#2-8-Java中运算符的优先级（从上到下，由高到低）" class="headerlink" title="2.8 Java中运算符的优先级（从上到下，由高到低）"></a>2.8 Java中运算符的优先级（从上到下，由高到低）</h4><p><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228150822.png" alt=""></p><h4 id="2-9-表达式中的类型转换"><a href="#2-9-表达式中的类型转换" class="headerlink" title="2.9 表达式中的类型转换"></a>2.9 表达式中的类型转换</h4><p>int→long→float→double<br>所有的byte、short、char参与算术运算都转为int</p><h3 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3. 流程控制语句"></a>3. 流程控制语句</h3><h4 id="3-1-if语句"><a href="#3-1-if语句" class="headerlink" title="3.1 if语句"></a>3.1 if语句</h4><p>语法：</p><pre><code>if(条件){    条件成立时执行的代码}</code></pre><h4 id="3-2-if…else语句"><a href="#3-2-if…else语句" class="headerlink" title="3.2 if…else语句"></a>3.2 if…else语句</h4><p>语法：</p><pre><code>if(条件的布尔表达式){    代码块1}else{    代码块2}</code></pre><h4 id="3-3-多重if语句"><a href="#3-3-多重if语句" class="headerlink" title="3.3 多重if语句"></a>3.3 多重if语句</h4><p>语法：</p><pre><code>if(条件1){    代码块1}else if(条件2){    代码块2}else{    代码块3}</code></pre><h4 id="3-4-if嵌套语句"><a href="#3-4-if嵌套语句" class="headerlink" title="3.4 if嵌套语句"></a>3.4 if嵌套语句</h4><p>语法：</p><pre><code>if(条件1){    if(条件2){        代码块1    }else{        代码块2    }}else{    代码块3}</code></pre><h4 id="3-5-switch语句"><a href="#3-5-switch语句" class="headerlink" title="3.5 switch语句"></a>3.5 switch语句</h4><p>语法：</p><pre><code>switch(表达式){    case 值1:        执行代码块1  break;    case 值2:        执行代码块2  break;    case 值n:        执行代码块n  break;    default :        默认执行的代码}</code></pre><p><code>注意事项：</code></p><blockquote><ol><li>switch 后面小括号中表达式的值必须是整型或字符型</li><li>case 后面的值可以是常量数值，如 1、2；也可以是一个常量表达式，如 2+2 ；但不能是变量或带有变量的表达式，如 a * 2</li><li>case 匹配后，执行匹配块里的程序代码，如果没有遇见 break 会继续执行下一个的 case 块的内容，直到遇到 break 语句或者 switch 语句块结束</li><li>把功能相同的case语句合并起来，如:<pre><code> case 1: case 2:     system.out.println("1024")</code></pre></li><li>default块可以出现在任意位置，也可以省略</li></ol></blockquote><h4 id="3-6-循环语句"><a href="#3-6-循环语句" class="headerlink" title="3.6 循环语句"></a>3.6 循环语句</h4><h5 id="3-6-1-循环语句之while"><a href="#3-6-1-循环语句之while" class="headerlink" title="3.6.1 循环语句之while"></a>3.6.1 循环语句之while</h5><p>语法：</p><pre><code>while(判断条件){    操作代码块}</code></pre><p>执行过程：<br>1.判断while后面的条件是否成立<br>2.当条件成立时，执行循环内的操作代码，然后重复执行1和2，直到循环条件不成立为止<br>特点：<code>先判断，后执行</code></p><h5 id="3-6-2-循环语句之do…while"><a href="#3-6-2-循环语句之do…while" class="headerlink" title="3.6.2 循环语句之do…while"></a>3.6.2 循环语句之do…while</h5><p>语法：</p><pre><code>do{    操作代码块}while(判断条件);</code></pre><p>执行过程：<br>1.先执行一遍操作代码，然后帕帕尼段循环条件是否成立<br>2.若条件成立，继续执行1和2，直到条件不成立为止<br>特点：<code>先执行，后判断</code></p><ul><li>do…while语句保证循环至少被执行一次！</li></ul><h5 id="3-6-3-循环语句之for"><a href="#3-6-3-循环语句之for" class="headerlink" title="3.6.3 循环语句之for"></a>3.6.3 循环语句之for</h5><p>语法：</p><pre><code>for (循环变量初始化;循环条件;循环变量变化){    操作代码块}</code></pre><p>执行过程：<br>1.执行循环变量初始化部分，设置循环的初始状态，此<br>部分在整个循环中只执行一次<br>2.进行循环条件的判断，如果条件为 true ，则执行循环<br>体内代码；如果为 false ，则直接退出循环<br>2.执行循环变量变化部分，改变循环变量的值，以便进<br>行下一次条件判断<br>4.依次重新执行2.3.4，直到退出循环<br>特点：<code>相比 while 和 do...while 语句结构更加简洁易读</code></p><p>for循环小细节：</p><blockquote><ol><li>for 关键字后面括号中的三个表达式必须用 “;” 隔开，三个表达式都可以省略，但 “;” 不能省略<br> a.省略“循环变量初始化”，可以在 for 语句之前由赋值语句进行变量初始化操作<br> b.省略“循环条件”，可能会造成循环将一直执行下去，也就是我们常说的“死循环”现象<br> c.省略“循环变量变化”，可以在循环体中进行循环变量的变化</li><li>for 循环变量初始化和循环变量变化部分，可以是使用 “,” 同时初始化或改变多个循环变量的值</li><li>循环条件部分可以使用逻辑运算符组合的表达式，表示复杂判断条件，但一定注意运算的优先级</li></ol></blockquote><h5 id="3-6-4-循环跳转语句之break"><a href="#3-6-4-循环跳转语句之break" class="headerlink" title="3.6.4 循环跳转语句之break"></a>3.6.4 循环跳转语句之break</h5><p>用法示例：</p><pre><code>public static void main(String[] args){    for(int i=1;i&lt;=10;i++&gt;){        if((i&gt;2) &amp;&amp; (i%3==0)){            //通过break结束循环，执行循环后的语句            break;        }        System.out.println(i);    }    System.out.println("结束")}</code></pre><h5 id="3-6-5-循环跳转语句之continue"><a href="#3-6-5-循环跳转语句之continue" class="headerlink" title="3.6.5 循环跳转语句之continue"></a>3.6.5 循环跳转语句之continue</h5><p>用法示例：</p><pre><code>public static void main(String[] args){    for(int i=1;i&lt;=10;i++&gt;){        if(i % 2 != 0){            //通过continue结束本次循环，直接进行下一次循环            continue;        }        System.out.println(i);    }    System.out.println("结束")}</code></pre><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h3><h4 id="4-1-一维数组"><a href="#4-1-一维数组" class="headerlink" title="4.1 一维数组"></a>4.1 一维数组</h4><ul><li>声明方式：<ul><li>int[] a;</li><li>double []b;</li><li>Mydate c[];<br>注：方括号可写到变量名前，也可写到变量名后</li></ul></li><li>数组初始化：<ul><li><code>int[] a = new int[3]</code>      分配3个空间</li><li><code>a[0]=1;  a[1]=2;   a[2]=3;</code><br>注：<code>数组定义与为数组分配空间分开进行</code></li></ul></li><li>数组静态初始化：<ul><li><code>int[] a={1,2,3};</code>   或</li><li><code>int[] a=new int[]{1,2,3};</code></li></ul></li><li>数组元素的引用：<br>每个数组都有个属性length指明其长度<br>例：ages.length指明数组a的长度, <code>for(int i=0;i&lt;ages.length;i++)</code></li></ul><h4 id="4-2-二维数组"><a href="#4-2-二维数组" class="headerlink" title="4.2 二维数组"></a>4.2 二维数组</h4><p>声明方式：</p>int [][] t={{1,2},{3,4,5},{6,7,8}};<p>数组可写为<code>int [][] t=new int [3][];</code><br>不可写为<code>int [][] t=new int [][4];</code></p><h4 id="4-3-数组赋值的常用方法"><a href="#4-3-数组赋值的常用方法" class="headerlink" title="4.3 数组赋值的常用方法"></a>4.3 数组赋值的常用方法</h4><ol><li>for循环，效率最低</li><li>System.arraycopy() 效率最高</li><li>Arrays.copyOf() 效率次于第二种方法</li><li>Object.clone() 效率次于第二种和第三种</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础.2 简单的Java程序</title>
      <link href="/posts/de73.html"/>
      <url>/posts/de73.html</url>
      
        <content type="html"><![CDATA[<h1 id="第2讲-简单的Java程序"><a href="#第2讲-简单的Java程序" class="headerlink" title="第2讲 简单的Java程序"></a>第2讲 简单的Java程序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第2讲主要讲述：Java程序的类型与基本构成，开发Java程序的基本步骤及在程序中进行输入输出</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Java程序的类型与基本构成"><a href="#1-Java程序的类型与基本构成" class="headerlink" title="1. Java程序的类型与基本构成"></a>1. Java程序的类型与基本构成</h3><ul><li>package语句：package包，表明源程序位于什么路径下(0或1句)</li><li>import语句：导入其他类(0或多句)</li><li>类定义class：可以有多个class类，但一个文件只能有一个public类(与文件同名)</li></ul><h3 id="2-开发Java程序的基本步骤"><a href="#2-开发Java程序的基本步骤" class="headerlink" title="2. 开发Java程序的基本步骤"></a>2. 开发Java程序的基本步骤</h3><h4 id="2-1-JDK安装后的文件夹"><a href="#2-1-JDK安装后的文件夹" class="headerlink" title="2.1 JDK安装后的文件夹"></a>2.1 JDK安装后的文件夹</h4><table><thead><tr><th>文件夹名</th><th align="center">存放的文件类型</th></tr></thead><tbody><tr><td>Bin</td><td align="center">存放工具文件</td></tr><tr><td>Demo</td><td align="center">存放一些示例文件</td></tr><tr><td>Jre</td><td align="center">存放与Java运行环境相关的文件</td></tr><tr><td>Include</td><td align="center">存放与C相关的头文件</td></tr><tr><td>Lib</td><td align="center">存放程序库</td></tr><tr><td>Db</td><td align="center">数据库相关</td></tr></tbody></table><h4 id="2-2-Java的API文档"><a href="#2-2-Java的API文档" class="headerlink" title="2.2 Java的API文档"></a>2.2 Java的API文档</h4><ul><li>英文在线文档：<a href="http://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">文档链接</a></li><li>中文在线文档：<a href="http://www.matools.com/api/java8" target="_blank" rel="noopener">文档链接</a><ul><li>注：尽可能多去看API英文文档</li></ul></li></ul><h3 id="3-程序中进行输入与输出"><a href="#3-程序中进行输入与输出" class="headerlink" title="3. 程序中进行输入与输出"></a>3. 程序中进行输入与输出</h3><h4 id="3-1-文本界面"><a href="#3-1-文本界面" class="headerlink" title="3.1 文本界面"></a>3.1 文本界面</h4><ul><li>java.util.Scanner类<ul><li>整数：nteger.parseInt(s);      </li><li>实数：Double.parseDouble(s);    <pre><code>package test00;import java.util.Scanner;public class test00 {public static void main(String args[]){  Scanner scanner = new Scanner(System.in);  System.out.print("Please input a number:");  int a = scanner.nextInt();  System.out.print("%d的平方是%d\n,a,a*a)}}</code></pre></li></ul></li></ul><h4 id="3-2-图形界面"><a href="#3-2-图形界面" class="headerlink" title="3.2 图形界面"></a>3.2 图形界面</h4><pre><code>package test00;improt java.awt.*;import java.awt.event.*;import javax.swing.*;public calss test00{    public static void main(String args[])    {        new AppFrame();    }}class AppFrame extends JFrame{    JTextField in = new JTextField(10);    JButton btn = new JButton("求平方");    JLable out = new JLabel("用于显示结果的标签");}public AppFrame(){    setLayout(new FlowLayout());    getContentPane().add(in);    getContentPane().add(btn);    getContentPane().add(out);    btn.addActionListener(e -&gt;{        String s = in.getText();        Double d = Double.parseDouble(s);        double sq = Math.sqrt(d);        out.setText(d+"的平方根是："+sq)    })}</code></pre><ul><li>运行后：<br><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228141615.png" alt=""></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础.1 Java语言与面向对象的程序设计</title>
      <link href="/posts/7a13.html"/>
      <url>/posts/7a13.html</url>
      
        <content type="html"><![CDATA[<h1 id="第1讲-Java语言与面向对象的程序设计"><a href="#第1讲-Java语言与面向对象的程序设计" class="headerlink" title="第1讲 Java语言与面向对象的程序设计"></a>第1讲 Java语言与面向对象的程序设计</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第1讲主要讲述：Java与C++的关系；Java程序的编译及运行；JDK及工具</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Java与C-的关系"><a href="#1-Java与C-的关系" class="headerlink" title="1. Java与C++的关系"></a>1. Java与C++的关系</h3><p>Java可以看做是C++做减法，取其精华去其糟粕，在Java中：</p><ul><li>无直接指针操作</li><li>自动内存管理</li><li>数据类型长度固定</li><li>不用头文件</li><li>不包含结构和联合</li><li>不支持宏</li><li>不用多重继承</li><li>无类外全局变量</li><li>无GOTO</li></ul><h3 id="2-Java程序的编译与运行"><a href="#2-Java程序的编译与运行" class="headerlink" title="2. Java程序的编译与运行"></a>2. Java程序的编译与运行</h3><p><img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/20200228125816.png" alt=""></p><h3 id="3-JDK及工具"><a href="#3-JDK及工具" class="headerlink" title="3. JDK及工具"></a>3. JDK及工具</h3><h4 id="3-1-JDK"><a href="#3-1-JDK" class="headerlink" title="3.1 JDK"></a>3.1 JDK</h4><ul><li>若要开发Java程序，则要下载JDK：<a href="http://jaava.sun.com" target="_blank" rel="noopener">下载地址</a></li><li>若只运行Java程序，可只下载JRE：<a href="http://java.com" target="_blank" rel="noopener">下载地址</a></li></ul><h4 id="3-2-常见的三类开发环境"><a href="#3-2-常见的三类开发环境" class="headerlink" title="3.2 常见的三类开发环境"></a>3.2 常见的三类开发环境</h4><p>1.直接使用JDK</p><ul><li>Javac,java,appletViewer</li></ul><p>2.文本工具+调用JDK命令</p><ul><li>Sublime Text,Notepad++,UltraEdit,EditPlus</li><li>JCreator,Kawa,Freejava</li></ul><p>3.集成开发环境(IDE)</p><ul><li>Eclipse,NetBeans(被广泛使用的两款)</li><li>Jdeveloper,VisualAge for Java</li><li>Bluej(主要用于教学)</li></ul><h4 id="3-3-推荐的几款IDE"><a href="#3-3-推荐的几款IDE" class="headerlink" title="3.3 推荐的几款IDE"></a>3.3 推荐的几款IDE</h4><p>Eclipse(免费)：<a href="http://www.eclipse.org/downloads/" target="_blank" rel="noopener">下载地址</a><br>NetBeans(免费)：<a href="http://java.sun.com" target="_blank" rel="noopener">下载地址</a><br>IntelliJ IDEA(开源版免费)：<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">下载地址</a></p><h5 id="3-3-1-Eclipse相关"><a href="#3-3-1-Eclipse相关" class="headerlink" title="3.3.1 Eclipse相关"></a>3.3.1 Eclipse相关</h5><ul><li>代码生成快捷键：可见Window-Preferences-Java-Editor-Templates</li><li>Eclipse中的窗体设计<ul><li>项目上点右键</li><li>New-Other-Windows Builder-Swing Designer-Jframe</li><li>在窗体上右键，Layout-absolute</li><li>加上按钮等组件，左下角设置其属性</li><li>组件上右键，Add New Event Handler</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="/posts/cf60.html"/>
      <url>/posts/cf60.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次接触Markdown标记语言，于是找了些Markdown常用格式，在此留档。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>以下为Markdown常用格式</p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><ul><li>使用符号：#<blockquote><p>#一级标题<br>##二级标题<br>###三级标题<br>####四级标题<br>#####五级标题<br>######六级标题<br>注：符号#和文本之间要保留一个字符的空格</p></blockquote></li><li>例：我楼下的列表俩字就是栗子</li></ul><h3 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h3><ul><li>使用符号：-<blockquote><p>-文本1<br>-文本2<br>-文本3<br>有序列表可用1.,2.,3.等代替符号-来表示(???为什么我下面用了没实现)<br>注：符号#和文本之间要保留一个字符的空格</p></blockquote></li><li>例：<ol><li>我现在就是</li><li>是个栗</li><li>子</li></ol></li></ul><h3 id="3-链接和图片"><a href="#3-链接和图片" class="headerlink" title="3.链接和图片"></a>3.链接和图片</h3><ul><li>使用符号：!,[]和() <blockquote><p>插入链接格式：[] (),[]内填写文本信息，()内填写链接地址<br>插入图片格式：! [] ()，[]内留空，()内填写图片地址<br>注：各个符号间不留空</p></blockquote></li><li>例：<br>链接：<a href="https://leeyin98.com/posts/3eeb.html" target="_blank" rel="noopener">原地TP</a><br>图片：<img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/logo.png" alt=""></li></ul><h3 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h3><ul><li>使用符号：&gt;<blockquote><p>模板：&gt; 文本信息，&gt;&gt; 文本信息<br>需要引用时，文字前添加符号&gt;即可，&gt;&gt;表示引用内再次引用<br>注：符号&gt;和文本要保留一个字符的空格</p></blockquote></li><li>例：<blockquote><p>我是一<br>个栗<br>子</p></blockquote></li></ul><h3 id="5-字体"><a href="#5-字体" class="headerlink" title="5.字体"></a>5.字体</h3><ul><li>使用符号： *<blockquote><p>粗体：用两个符号<em>包含一段文字<br>斜体：用一个符号</em>包含一段文字</p></blockquote></li><li>例：举个栗子，<em>我是斜体</em>，<strong>我是粗体</strong>。</li></ul><h3 id="6-代码应用"><a href="#6-代码应用" class="headerlink" title="6.代码应用"></a>6.代码应用</h3><ul><li>使用符号：`<blockquote><p>引用一行：用符号`包含语句<br>引用多行：将符号```置于代码的首行与末行</p></blockquote></li><li>例：<br>  单行：<code>This is a chestnut</code><br>  多行：<pre><code>  This     is       a        chestnut</code></pre></li></ul><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><ul><li>使用符号：|，-和:</li><li>例：<table><thead><tr><th>栗子No.x</th><th align="center">优点</th><th align="right">价格</th></tr></thead><tbody><tr><td>栗子No.0</td><td align="center">又长又宽</td><td align="right">$1024</td></tr><tr><td>栗子No.1</td><td align="center">又大又圆</td><td align="right">$512</td></tr><tr><td>栗子No.2</td><td align="center">好吃</td><td align="right">$256</td></tr></tbody></table></li></ul><p><code>Over!!!</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用格式</title>
      <link href="/posts/3eeb.html"/>
      <url>/posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我第一次使用WordPress搭建的第一个博客，但感觉自由度和可玩性不够高，于是转战Hexo。由于支持十分轻量方便的Markdown标记语言，但本人却是第一次接触该语言，所以搜集了些Markdown的常用写法，故在此留档，。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>以下为Markdown常用写法</p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><ul><li>使用符号：#<blockquote><p>#一级标题<br>##二级标题<br>###三级标题<br>####四级标题<br>#####五级标题<br>######六级标题<br>注：符号#和文本之间要保留一个字符的空格</p></blockquote></li><li>例：我楼下的列表俩字就是栗子</li></ul><h3 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h3><ul><li>使用符号：-<blockquote><p>-文本1<br>-文本2<br>-文本3<br>有序列表可用1.,2.,3.等代替符号-来表示(???为什么我下面用了没实现)<br>注：符号#和文本之间要保留一个字符的空格</p></blockquote></li><li>例：<ol><li>我现在就是</li><li>是个栗</li><li>子</li></ol></li></ul><h3 id="3-链接和图片"><a href="#3-链接和图片" class="headerlink" title="3.链接和图片"></a>3.链接和图片</h3><ul><li>使用符号：!,[]和() <blockquote><p>插入链接格式：[] (),[]内填写文本信息，()内填写链接地址<br>插入图片格式：! [] ()，[]内留空，()内填写图片地址<br>注：各个符号间不留空</p></blockquote></li><li>例：<br>链接：<a href="https://leeyin98.com/posts/3eeb.html" target="_blank" rel="noopener">原地TP</a><br>图片：<img src="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/loading.gif" data-original="https://cdn.jsdelivr.net/gh/leeyin98/figurebed/imgs/logo.png" alt=""></li></ul><h3 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h3><ul><li>使用符号：&gt;<blockquote><p>模板：&gt; 文本信息，&gt;&gt; 文本信息<br>需要引用时，文字前添加符号&gt;即可，&gt;&gt;表示引用内再次引用<br>注：符号&gt;和文本要保留一个字符的空格</p></blockquote></li><li>例：<blockquote><p>我是一<br>个栗<br>子</p></blockquote></li></ul><h3 id="5-字体"><a href="#5-字体" class="headerlink" title="5.字体"></a>5.字体</h3><ul><li>使用符号： *<blockquote><p>粗体：用两个符号<em>包含一段文字<br>斜体：用一个符号</em>包含一段文字</p></blockquote></li><li>例：举个栗子，<em>我是斜体</em>，<strong>我是粗体</strong>。</li></ul><h3 id="6-代码应用"><a href="#6-代码应用" class="headerlink" title="6.代码应用"></a>6.代码应用</h3><ul><li>使用符号：`<blockquote><p>引用一行：用符号`包含语句<br>引用多行：将符号```置于代码的首行与末行</p></blockquote></li><li>例：<br>  单行：<code>This is a chestnut</code><br>  多行：<pre><code>  This     is       a        chestnut</code></pre></li></ul><h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><ul><li>使用符号：|，-和:<blockquote><ul><li>第二行分割表头和内容。<br>有一个-就行，为了对齐，多加了几个</li><li>文字默认居左<br>两边加 ：表示文字居中<br>右边加 ：表示文字居右</li><li>文字和符号前要留个字符的空格</li></ul></blockquote></li><li>例：<table><thead><tr><th>栗子No.x</th><th align="center">优点</th><th align="right">价格</th></tr></thead><tbody><tr><td>栗子No.0</td><td align="center">又长又宽</td><td align="right">$1024</td></tr><tr><td>栗子No.1</td><td align="center">又大又圆</td><td align="right">$512</td></tr><tr><td>栗子No.2</td><td align="center">好吃</td><td align="right">$256</td></tr></tbody></table></li></ul><p><code>Over!!!</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
